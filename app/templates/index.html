{% extends "base.html" %}

<head>
  {% block head %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/index.css') }}">
  {% endblock %}
</head>

<body>
{% block content %}
<div class="chat-container">
  <div class="chat-header">AI ChatBot</div>
  <div id="chat-window" class="chat-window"></div>

  <form id="chat-form">
    <textarea id="question" placeholder="Type your question..." required></textarea>
    <button type="submit">Send</button>
    <button type="button" id="cancel-button" style="display:none;">Cancel</button>
  </form>
</div>
<script>
  const form = document.getElementById('chat-form');
  const chatWindow = document.getElementById('chat-window');
  const cancelButton = document.getElementById('cancel-button');

  var currentMessageDivText = null

  let controller = null;

  function addMessage(sender, text) {
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('message', sender);
    msgDiv.innerText = text;
    chatWindow.appendChild(msgDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  function createMessageDiv() {
        let botMsgDiv = document.createElement('div');
        botMsgDiv.classList.add('message', 'bot');
        botMsgDiv.innerText = '';

        return botMsgDiv
  }

  function handleMsgDataChunk(chunk) {
       var data = null


       try {

           if (typeof chunk === "string") {
               data = JSON.parse(chunk);
           } else {
               data = chunk
           }
       } catch (error) {
           throw new Error("error parsing chunk" + chunk + "\n" + err)
       }
       receivedAnyContent = true;

       if (data.type === 'error') {
           var currentMessageDiv = createMessageDiv()
           let errorUserMsg = ""
           let errorMsg = ""


           if (!data.error) {
               throw new Error("Received error from server but didnt contain error context in its data response.")
           }

           error = data.error.msg
           if (data.error.code === 1) {
               errorUserMsg = "The LLM gave a blank response"
           } else {
               errorUserMsg = errorMsg
           }

           currentMessageDiv.innerText += errorUserMsg;
           chatWindow.appendChild(currentMessageDiv);


           throw new Error(errorMsg)

       } else if (data.type === 'text') {

           if (currentMessageDivText == null) {
               currentMessageDivText = createMessageDiv()
               chatWindow.appendChild(currentMessageDivText)
           }


           currentMessageDivText.innerText += data.content;
           chatWindow.appendChild(currentMessageDivText);
            chatWindow.scrollTop = chatWindow.scrollHeight;
       } else if (data.type === 'question') {
           var currentMessageDiv = createMessageDiv()
           currentMessageDiv.classList.add('question');
           currentMessageDiv.id = data.question_id

           // Create and add question text
           const questionText = document.createElement('div');
           questionText.className = 'question-text';
           questionText.innerText = data.content;
           currentMessageDiv.appendChild(questionText);
           chatWindow.appendChild(currentMessageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;

           // Create form for choices
           const choiceForm = document.createElement('div');
           choiceForm.className = 'choice-form';
           let buttons = []

           data.choices.forEach(choice => {
               const button = document.createElement('button');
               buttons.push(button)
               button.className = 'choice-button';

               if (choice) {
                   choice = choice.charAt(0).toUpperCase() + choice.slice(1);
               }

               button.innerText = choice;

               button.onclick = () => {
                   fetch('/answer', {
                       method: 'POST',
                       headers: {
                           'Content-Type': 'application/json'
                       },
                       body: JSON.stringify({"question_id": data.question_id, "answer": choice}),
                   })
                   .then(response => {
                       if (!response.ok) {
                           throw new Error(`HTTP error! status: ${response.status}`);
                       }
                       button.style.color = "green"
                       buttons.forEach((btn) => {
                           btn.disabled = true
                       })

                       return response.json();  // or response.text(), etc.
                   })
                   .then(data => {
                       console.log('Response data:', data);
                       if (data.hasOwnProperty("follow_ups")) {
                           data.follow_ups.forEach((chunk) => {
                               handleMsgDataChunk(chunk)
                           })
                       }
                   })
                   .catch(error => {
                       console.error('Fetch error:', error);
                   });
               };

               choiceForm.appendChild(button);
           });

           currentMessageDiv.appendChild(choiceForm);
           currentMessageDiv = null

       }

       chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const questionInput = document.getElementById('question');
    const question = questionInput.value.trim();
    if (!question) return;

    addMessage('user', question);
    questionInput.value = '';



    // Track if any text was added
    let receivedAnyContent = false;

    // AbortController for cancel support
    controller = new AbortController();
    const signal = controller.signal;

    cancelButton.style.display = 'inline';
    cancelButton.disabled = false;
    cancelButton.innerText = 'Cancel';

    cancelButton.onclick = () => {
      if (controller) {
        controller.abort();
        cancelButton.disabled = true;
        cancelButton.innerText = 'Canceled';
      }
    };

    try {
      const res = await fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ question }),
        signal
      });

      const reader = res.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let done = false;
      currentMessageDivText = createMessageDiv()
        chatWindow.appendChild(currentMessageDivText)


      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;

        if (value) {
          let chunk = decoder.decode(value);

          if (chunk.endsWith('\n\n')) {
            chunk = chunk.slice(0, -2);
          }

          if (chunk.startsWith('data: ')) {
            chunk = chunk.replace('data: ', '');
          }

          try {
              handleMsgDataChunk(chunk)
          } catch (err) {
              console.error(err)
          }
        }
      }

    } catch (err) {
      if (err.name === 'AbortError') {
        if (!receivedAnyContent && currentMessageDivText != null) {
          currentMessageDivText.remove(); // Remove empty bubble if nothing was streamed
            currentMessageDivText = null
        } else {
            let msgDiv = createMessageDiv() ? currentMessageDivText == null : currentMessageDivText
          msgDiv.innerText += '\n[Stream canceled]';
        }
      } else {
          let div = createMessageDiv()
        div.innerText = 'Error connecting to server.';
          chatWindow.appendChild(div)
      }
    } finally {
      cancelButton.style.display = 'none';
      cancelButton.innerText = 'Cancel';
      currentMessageDivText = null;
    }
  });
</script>

{% endblock %}
</body>
